## Variadic Templates
参数数量不定的模板参数
```cpp
//1
void print()
{

}
//2
template<typename T,typename... Types>
void print(const T& firstArgs,const Types&... args)
{
    cout<< firstArg << endl; //print first argument;
    print(args...);          //call print() for remaining arguments
}
```
`const Types&... args`表示函数会接收任意数量的参数，而且每一个参数的type都是任意的。这个功能可以帮助我们递归函数调用，递归调用的目的是为了分解不定数量的参数。
```cpp
print(7.5,"hello",bitset<16>(377),42);
```
第一次调用，第一个参数是7.5，其余参数是["hello",bitset<16>(377),42]；
第二次调用，第一个参数是"hello"，其余参数[bitset<16>(377),42]；
第三次调用，第一个参数是"bitset<16>(377)，其余参数是42；
第四次调用，第一个参数是42，其余参数为空；
第五次调用，参数为空，到达边界条件，此时调用`print()`函数。

因此上面的代码会递归调用print()函数。最终会打印出7.5,hello,00000001011111001,42。

**...** 就是一个所谓的**pack**(包)
用于template parameters，就是template parameters **pack**(模板参数**包**)
用于function parameter types，function parameters types **pack**(函数参数类型**包**)
用于function parameters，就是function parameters **pack**(函数参数**包**)

在边长模板中，`sizeof...(args)`计算参数的数量。


```cpp
//3
template<typename... Types>
void print(const Types&... args)
{/*...*/}
```
代码2和代码3可以并存吗？如果可以，谁比较泛化，谁比较特化？

### 可以很方便地完成recursive function call(例子1)

```cpp
class CustomerHash{
public:
    std::size_t operator()(const Customer& c) const{
        return hash_val(c.fname,c.lname,c.no);
    }
};
```
简述上面类的成员函数的调用逻辑

```cpp
//1
template<typename.. Types>
inline size_t hash_val(const Types&... args){
    size_t seed = 0;
    hash_val(seed,args...);
    return seed;
}
```
函数1接收一包参数

```cpp
//2
template<typename T,typename.. Types>
inline void hash_val(size_t& seed,const T& val,const Types&... args){
    hash_combine(seed,val);
    hash_val(seed,args...);  // recursive
}
```
函数2接收3个参数，分别是第一个参数、第二个参数、一包参数。
```cpp
//3
template<typename T>
inline void hash_val(size_t& seed,const T& val){
    hash_combine(seed,val);
}
```
函数3接收2个参数，分别是第一个参数，一包参数。
```cpp
//4
#include<functional>
template<typename T>
inline void hash_combine(size_t& seed,const T& val){
    seed ^= std::hash<T>()(val) + 0x9e3779b9+seed(<<6)+(seed>>2);
}
```
1. 根据参数类型可知，成员函数先调用函数1；
2. 由于函数2比函数1内部的`hash_val(seed,args...)`更加特化，所以函数1会调用函数2；
3. 函数2调用函数4即`hash_combine(size_t& seed,const T& val)`；
4. 函数2开始递归调用自身；
5. 函数2到达递归边界，入参的一包参数数量为0。恰好调用函数3。


### 可以很方便地完成recursive function call(例子2)
tuple 是一个可以放置任意数量任意类型元素的集合。
```cpp
template<typename... Values>class tuple;
template<> class tuple<>{};
```

```cpp
template<typename Head,typename... Tail>
class tuple<Head,Tail>
:private tuple<Head,Tail...>  // 可以很方便的完成recursive inheritance
{
    typedef tuple<Tail...> inherited;
    public:
        tuple(){}
        tuple(Head v,Tail... vtail)
            // 注意这里是initialization list
            :m_head(v),inherited(vtail...){} // 调用base ctor 并给参数(不要误认为是创建tmp object)

        typename Head::type head(){return m_head;}
        inherited& tail(){return *this;}
    protected:
        Head m_head;
};
```
首先看下递归继承是如何完成的。例如`tuple<int,float,string>t(41,6.3,"nico")`，它的递归继承关系如下：
<div align=center>
<img src="../CppNewFeature/image/inage1.png"/>
</div>

注意递归的边界函数`template<> class tuple<>{};`



