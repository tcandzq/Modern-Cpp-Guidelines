## Variadic Templates
参数数量不定的模板参数
```cpp
//1
void print()
{

}
//2
template<typename T,typename... Types>
void print(const T& firstArgs,const Types&... args)
{
    cout<< firstArg << endl; //print first argument;
    print(args...);          //call print() for remaining arguments
}
```
`const Types&... args`表示函数会接收任意数量的参数，而且每一个参数的type都是任意的。这个功能可以帮助我们递归函数调用，递归调用的目的是为了分解不定数量的参数。
```cpp
print(7.5,"hello",bitset<16>(377),42);
```
第一次调用，第一个参数是7.5，其余参数是["hello",bitset<16>(377),42]；
第二次调用，第一个参数是"hello"，其余参数[bitset<16>(377),42]；
第三次调用，第一个参数是"bitset<16>(377)，其余参数是42；
第四次调用，第一个参数是42，其余参数为空；
第五次调用，参数为空，到达边界条件，此时调用`print()`函数。

因此上面的代码会递归调用print()函数。最终会打印出7.5,hello,00000001011111001,42。

**...** 就是一个所谓的**pack**(包)
用于template parameters，就是template parameters **pack**(模板参数**包**)
用于function parameter types，function parameters types **pack**(函数参数类型**包**)
用于function parameters，就是function parameters **pack**(函数参数**包**)

在边长模板中，`sizeof...(args)`计算参数的数量。


```cpp
//3
template<typename... Types>
void print(const Types&... args)
{/*...*/}
```
代码2和代码3可以并存吗？如果可以，谁比较泛化，谁比较特化？

### 可以很方便地完成recursive function call(例子1)

```cpp
class CustomerHash{
public:
    std::size_t operator()(const Customer& c) const{
        return hash_val(c.fname,c.lname,c.no);
    }
};
```
简述上面类的成员函数的调用逻辑

```cpp
//1
template<typename.. Types>
inline size_t hash_val(const Types&... args){
    size_t seed = 0;
    hash_val(seed,args...);
    return seed;
}
```
函数1接收一包参数

```cpp
//2
template<typename T,typename.. Types>
inline void hash_val(size_t& seed,const T& val,const Types&... args){
    hash_combine(seed,val);
    hash_val(seed,args...);  // recursive
}
```
函数2接收3个参数，分别是第一个参数、第二个参数、一包参数。
```cpp
//3
template<typename T>
inline void hash_val(size_t& seed,const T& val){
    hash_combine(seed,val);
}
```
函数3接收2个参数，分别是第一个参数，一包参数。
```cpp
//4
#include<functional>
template<typename T>
inline void hash_combine(size_t& seed,const T& val){
    seed ^= std::hash<T>()(val) + 0x9e3779b9+seed(<<6)+(seed>>2);
}
```
1. 根据参数类型可知，成员函数先调用函数1；
2. 由于函数2比函数1内部的`hash_val(seed,args...)`更加特化，所以函数1会调用函数2；
3. 函数2调用函数4即`hash_combine(size_t& seed,const T& val)`；
4. 函数2开始递归调用自身；
5. 函数2到达递归边界，入参的一包参数数量为0。恰好调用函数3。


### 可以很方便地完成recursive function call(例子2)
tuple 是一个可以放置任意数量任意类型元素的集合。
```cpp
template<typename... Values>class tuple;
template<> class tuple<>{};
```

```cpp
template<typename Head,typename... Tail>
class tuple<Head,Tail>
:private tuple<Head,Tail...>  // 可以很方便的完成recursive inheritance
{
    typedef tuple<Tail...> inherited;
    public:
        tuple(){}
        tuple(Head v,Tail... vtail)
            // 注意这里是initialization list
            :m_head(v),inherited(vtail...){} // 调用base ctor 并给参数(不要误认为是创建tmp object)

        typename Head::type head(){return m_head;}
        inherited& tail(){return *this;}
    protected:
        Head m_head;
};
```
首先看下递归继承是如何完成的。例如`tuple<int,float,string>t(41,6.3,"nico")`，它的递归继承关系如下：
<div align=center>
<img src="../CppNewFeature/image/inage1.png"/>
</div>

注意递归的边界函数`template<> class tuple<>{};`

### nullptr and std::nullptr_t
C++11允许你用


### Initializer List
```cpp
int i; // i has undefined value
int j{}; // j is initialized by 0
int* p; // p has undefined value
int* q{}; // q is initialized by nullptr
```
Note, however, that narrowing initializations — those that reduce precision or where the supplied value gets modified — are not possible with braces. For example:
```cpp
int x1(5.3); // OK, but OUCH: x1 becomes 5
int x2 = 5.3; // OK, but OUCH: x2 becomes 5
int x3{5.0}; // ERROR: narrowing
int x4 = {5.3}; // ERROR: narrowing
char c1{7}; // OK: even though 7 is an int, this is not narrowing
char c2{99999}; // ERROR: narrowing (if 99999 doesn’t fit into a char)
std::vector<int> v1 { 1, 2, 4, 5 }; // OK
std::vector<int> v2 { 1, 2.3, 4, 5.6 }; // ERROR: narrowing doubles to ints
```

To support the concept of initializer lists for user-defined types, C++11 provides the class template `std::initializer_list<>`. It can be used to support initializations by a list of values or in any other place where you want to process just a list of values. For example:
```cpp
void print (std::initializer_list<int> vals)
{
for (auto p=vals.begin(); p!=vals.end(); ++p) { // process a list of values
std::cout << *p << "\n";
}
}
print ({12,3,5,7,11,13,17}); // pass a list of values to print()
```

When there are constructors for both a specific number of arguments and an initializer list, the version with the initializer list is preferred:
```cpp
class P
{
public:
    P(int a,int b)
    {
        cout << "P(int,int),a = " <<  a << ",b=" << b << endl;
    }
    P(std::initializer_list<int>)
    {
        cout << "P(initializer_list<int>),value=";
        for(auto i:initlist)
            cout << i << ' ';
        cout << endl;
    }
};
P p(77,5); // calls P::P(int,int)
P q{77,5}; // calls P::P(initializer_list) 
P r{77,5,42}; // calls P::P(initializer_list)
P s = {77,5}; // calls P::P(initializer_list)
```

Without the constructor for the initializer list, the constructor taking two ints would be called to initialize q and s, while the initialization of r would be invalid.

```cpp
class P
{
public:
    P(int a,int b)
    {
        cout << "P(int,int),a = " <<  a << ",b=" << b << endl;
    }
    P(std::initializer_list<int>)
    {
        cout << "P(initializer_list<int>),value=";
        for(auto i:initlist)
            cout << i << ' ';
        cout << endl;
    }
};

```
initializer_list objects are automatically constructed as if an array of elements of type T was allocated, with each of the elements in the list being copy-initialized to its corresponding element in the array, using any necessary non-narrowing implicit conversions.

The initializer_list object refers to the elements of this array without containing them: copying an initializer_list object produces another object referring to the same underlying elements, not to new copies of them (reference semantics).

The lifetime of this temporary array is the same as the initializer_list object.




### explicit for ctors taking more than one argument
`explict`只用在构造函数里面，显示的禁止隐式的转换。在C++2.0以前，只能用于带有一个实参的构造函数，叫做nonexplict one argument constructor。
```cpp
class P
{
public:
    P(int a,int b)
    {
        cout << "P(int,int),a = " <<  a << ",b=" << b << endl;
    }
    P(std::initializer_list<int>)
    {
        cout << "P(initializer_list<int>),value=";
    }
    explicit P(int a, int b, int c) {
        cout << "explicit P(int a, int b, int c) \n";
    }
};

void fp(const P&){ };
```

### Range-Based for Loops
```cpp
for ( int i : { 2, 3, 5, 7, 9, 13, 17, 19 } ) {
    std::cout << i << std::endl;
}
```
```cpp
std::vector<double> vec;
...
for (auto elem : vec){
    cout << elem << endl;
}

for ( auto& elem : vec ) {
    elem *= 3;
}
```

```cpp
for ( decl : coll ) {
    statement
}

```

```cpp
{
    for (auto _pos=coll.begin(); _pos != coll.end(); ++_pos ) {
        decl = *_pos;
        statement
    }
}

```
is equivalent to the following, if coll provides begin() and end() members:
```cpp
{
    for (auto _pos=begin(coll), _end=end(coll); _pos!=_end; ++_pos ) {
        decl = *_pos;
        statement
    }
}

```

```cpp
template <typename T>
void printElements (const T& coll)
{
    for (const auto& elem : coll) {
        std::cout << elem << std::endl;
    }
}

```

```cpp
{
    for (auto _pos=coll.begin(); _pos != coll.end(); ++_pos ) {
        const auto& elem = *_pos;
        std::cout << elem << std::endl;
    }
}

```

### explicit

Note that no explicit type conversions are possible when elements are initialized as decl inside the for loop. Thus, the following does not compile:
```cpp
class C
{
    public:
        explicit C(const std::string& s); // explicit(!) type conversion from strings
        ...
};


std::vector<std::string> vs;
for (const C& elem : vs) { // ERROR, no conversion from string to C defined
    std::cout << elem << std::endl;
}

```

### =default，=delete
如果你自行定义了一个ctor，那么编译器就不会再给你一个 `default ctor`。

如果你强制加上=default，就可以重新获得并使用`default ctor`

一般的函数没有=default和=delete的功能。

```cpp

class Zoo
{
public:
    Zoo(int i1,int i2):d1(i1),d2(i2){ }
    Zoo(comst Zoo&) = delete;
    Zoo(Zoo&&) = default;
    Zoo& operator=(const Zoo&) =default;
    Zoo& operator=(const Zoo&) =delete;
    virtual ~Zoo(){ }
private:
    int d1,d2;
}

```
**构造函数可以有多个，但拷贝构造函数和拷贝赋值构造函数只能有一个。**
```cpp
class Foo
{
public:
    Foo(int i):_i(i){ }
    Foo() = default // 和上一个ctor同时存在

    Foo(const Foo& x):_i(x._i){ }
    Foo(const Foo&) = default;  // [Error]'Foo::Foo(const Foo&)' cannot be overload
    Foo(const Foo&) = delete;  // [Error]'Foo::Foo(const Foo&)' cannot be overload

    Foo& operator=(const Foo& x){_i = x._i;return *this;}
    Foo& operator=(const Foo& x){_i = x._i;return *this;}// [Error]'Foo::Foo& operator=(const Foo& x)' cannot be overload
    Foo& operator=(const Foo& x){_i = x._i;return *this;}// [Error]'Foo::Foo& operator=(const Foo& x)' cannot be overload

    void func1() = default; //[Error]'void Foo::func1()'cannot be defaulted
    void func2() = delete; // OK

    ~Foo()=delete; // 这会造成Foo object 时出错，=> [Error]use of deleted function 'Foo::~Foo()'
    ~Foo()=default; //

private:
    int _i;
}

```
**=default;**用于Big-Five之外是何意义？——>无意义，编译会报错。
**=delete；**可以用在任何函数身上(=0只能用于virtual函数)。

如果一个类含有指针，通常要写Big-Three，如果一个类不含有指针，则绝大部分使用默认的Big-Three就够了


### 移动语义和右值引用

### 移动语义
右值引用主要解决下面两个问题
- 实现移动语义
- 完美转发

#### 左值
可能出现在赋值语句左边或者右边的表达式。

#### 右值
只能出现在赋值语句右边的表达式。

例如：
```cpp
int a = 42;
int b = 43;

// a 和 b都是左值
a = b // ok
b = a // ok
a = a * b // ok

// a * b 是右值
int c = a * b; // ok 右值在赋值语句的右边
a * b = 42; // error, 右值在赋值语句的左边
```
另外一种定义
#### 左值
左值是指向一块内存的表达式且可以通过运算符`&`获取该内存的地址。

#### 右值
不是左值的表达式就是右值。

```cpp
// 左值:
//
int i = 42;
i = 43; // ok, i是左值
int* p = &i; // ok, i是左值
int& foo();
foo() = 42; // ok, foo()是左值
int* p1 = &foo(); // ok, foo()是左值

// 右值:
//
int foobar();
int j = 0;
j = foobar(); // ok, foobar()是右值
int* p2 = &foobar(); // error, 不能获取右值的地址
j = 42; // ok, 42是右值

```

#### 移动语义
假设X是一个含有指针成员的类，这个指针指向某种资源，例如`m_pResource`。X的拷贝赋值构造函数是以下形式：
```cpp
X& X::operator=(X const & rhs)
{
  // [...]
  // Make a clone of what rhs.m_pResource refers to.
  // Destruct the resource that m_pResource refers to. 
  // Attach the clone to m_pResource.
  // [...]
}

```
假设X按照如下方式使用：
```cpp
X foo();
X x;
// perhaps use x in various ways
x = foo();
```
最后一行的含义：
- 从foo返回的临时对象中拷贝资源
- 销毁对象x持有的资源，并用克隆的资源替换它
- 销毁临时对象，从而释放其资源。

很明显，直接在对象x和临时对象之间交换资源指针，然后让临时对象的析构函数销毁原始资源会更有效率。换句话说

```cpp
// [...]
// swap m_pResource and rhs.m_pResource
// [...]  
```
上面这种交换方式称为移动语义。在C++11中，这种条件行为可以通过重载实现：
```cpp
X& X::operator=(<mystery type> rhs)
{
  // [...]
  // swap this->m_pResource and rhs.m_pResource
  // [...]  
}
```
因为重载了拷贝赋值运算符，所以`mystery type` 一定是一个引用。即拷贝赋值中=的右边是按照引用传递的。其中，一个函数的入参是常规引用，另一个函数的入参是`mystery type`。另外我们希望它还有另外一个行为：当选择两个重载函数之一时，右值对应于`mystery type`，左值对应于常规引用。

其实上面的`mystery type`就是右值引用。


#### 右值引用

假设X是任意类型，`X&&`称为X的右值引用。为了更好的区分，之前的常规引用`X&`称为左值引用。

右值引用也是一种类型，它的性质和左值引用`X&`非常类似。但它们一个最主要的区分在于解决函数重载问题，左值适用于左值引用，右值适用于右值引用。
```cpp
void foo(X& x); // lvalue reference overload
void foo(X&& x); // rvalue reference overload

X x;
X foobar();

foo(x); // argument is lvalue: calls foo(X&)
foo(foobar()); // argument is rvalue: calls foo(X&&)
```

### 字符串字面值


### 关键字noexcept


### 关键字constexper



### Lambdas


### 关键字decltype


### 新的函数声明语法


### 新的基础数据类型
- char16_t and char32_t
- long long and unsigned long long
- std::nullptr_t





参考1：http://thbecker.net/articles/rvalue_references/section_03.html
参考2：https://josephmansfield.uk/articles/lvalue-rvalue-metaphor.html
参考3：https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers

参考4:https://www.zhihu.com/search?type=content&q=%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC